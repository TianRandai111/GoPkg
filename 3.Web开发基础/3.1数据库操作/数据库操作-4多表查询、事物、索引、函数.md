# Mysql操作-4多表查询、事物、索引、函数

## 一、多表查询分类

将多个表的数据横向的联合起来。
1.	内连接
2.	外连接
	1. 左外连接
	2. 右外连接
3.	交叉连接
4.	自然连接

### 1.1 内连接 [inner join]

```mysql
语法一：select 列名 from 表1 inner jion 表2 on 表1.公共字段=表2.公共字段
语法二：select 列名 from 表1 , 表2 where 表1.公共字段 = 表2.公共字段
```

例题

```mysql
MySQL [test2]> select stuname,stusex,writtenexam,labexam from stuinfo inner join stuMarks on stuinfo.stuno=stuMarks.stuno;
+--------------+--------+-------------+---------+
| stuname      | stusex | writtenexam | labexam |
+--------------+--------+-------------+---------+
| 李斯文       | 女     |          80 |      58 |
| 李文才       | 男     |          50 |      90 |
| 欧阳俊雄     | 男     |          65 |      50 |
| 张秋丽       | 男     |          77 |      82 |
| 争青小子     | 男     |          56 |      48 |
+--------------+--------+-------------+---------+
5 rows in set (0.00 sec)

MySQL [test2]> select stuname,stusex,writtenexam,labexam from stuinfo,stuMarks where stuinfo.stuno=stuMarks.stuno;
+--------------+--------+-------------+---------+
| stuname      | stusex | writtenexam | labexam |
+--------------+--------+-------------+---------+
| 李斯文       | 女     |          80 |      58 |
| 李文才       | 男     |          50 |      90 |
| 欧阳俊雄     | 男     |          65 |      50 |
| 张秋丽       | 男     |          77 |      82 |
| 争青小子     | 男     |          56 |      48 |
+--------------+--------+-------------+---------+
5 rows in set (0.00 sec)

# 可以给表取别名
MySQL [test2]> select stuname,stusex,writtenexam,labexam from stuinfo as i ,stuMarks as v where i.stuno=v.stuno;
+--------------+--------+-------------+---------+
| stuname      | stusex | writtenexam | labexam |
+--------------+--------+-------------+---------+
| 李斯文       | 女     |          80 |      58 |
| 李文才       | 男     |          50 |      90 |
| 欧阳俊雄     | 男     |          65 |      50 |
| 张秋丽       | 男     |          77 |      82 |
| 争青小子     | 男     |          56 |      48 |
+--------------+--------+-------------+---------+
5 rows in set (0.00 sec)
```

>脚下留心：显示公共字段需要指定表名 

```mysql
MySQL [test2]> select stuno,stuname,stusex,writtenexam,labexam from stuinfo,stuMarks where stuinfo.stuno=stuMarks.stuno;
ERROR 1052 (23000): Column 'stuno' in field list is ambiguous

```

```mysql
MySQL [test2]> select stuinfo.stuno,stuname,stusex,writtenexam,labexam from stuinfo,stuMarks where stuinfo.stuno=stuMarks.stuno;
+--------+--------------+--------+-------------+---------+
| stuno  | stuname      | stusex | writtenexam | labexam |
+--------+--------------+--------+-------------+---------+
| s25303 | 李斯文       | 女     |          80 |      58 |
| s25302 | 李文才       | 男     |          50 |      90 |
| s25304 | 欧阳俊雄     | 男     |          65 |      50 |
| s25301 | 张秋丽       | 男     |          77 |      82 |
| s25318 | 争青小子     | 男     |          56 |      48 |
+--------+--------------+--------+-------------+---------+
5 rows in set (0.00 sec)
```
>思考：
>
>select * from 表1 inner join 表2 on 表1.公共字段=表2.公共字段  和
>
>select * from 表2 inner join 表1 on 表1.公共字段=表2.公共字段   结果是否一样？
>
>答：一样的，因为内连接获取的是两个表的公共部分

>多学一招：三个表的内连接如何实现？
>
>```mys
>qlselect * from 表1 inner join 表2 on 表1.公共字段=表2.公共字段 inner join 表3 on 表2.公共字段=表>=3.公共字段
>```

### 1.2 左外链接 [left join]

以左边的表为标准，如果有变的表没有对应的记录，用null填充

语法

```mysql
select 列名	from 表1 left 表2 on 表1.公共字段=表2.公共字段
```

例题

```mysql
MySQL [test2]> select stuname,writtenexam,labexam from stuinfo left join stuMarks on stuinfo.stuNo=stuMarks.stuno;
+--------------+-------------+---------+
| stuname      | writtenexam | labexam |
+--------------+-------------+---------+
| 李斯文       |          80 |      58 |
| 李文才       |          50 |      90 |
| 欧阳俊雄     |          65 |      50 |
| 张秋丽       |          77 |      82 |
| 争青小子     |          56 |      48 |
| 诸葛丽丽     |        NULL |    NULL |
| 梅超风       |        NULL |    NULL |
+--------------+-------------+---------+
7 rows in set (0.00 sec)
```

```mysql
思考：
select * from 表1 left join 表2 on 表1.公共字段=表2.公共字段
和
select * from 表2 left join 表1 on 表1.公共字段=表2.公共字段   是否一样？
答：不一样，左连接一左边的表为准。
```

### 1.3 右外连接[right join]

以右边的表标准，如果左边的表没有对应的记录值，用NULL填充

语法

```mysql
select 列名 from 表1 right join 表2 on 表1.公共字段=表2.公共字段
```

例题

```mysql
MySQL [test2]> select stuname,writtenexam,labexam from stuinfo right join stuMarks on stuinfo.stuNo=stuMarks.stuno;
+--------------+-------------+---------+
| stuname      | writtenexam | labexam |
+--------------+-------------+---------+
| 李斯文       |          80 |      58 |
| 李文才       |          50 |      90 |
| 欧阳俊雄     |          65 |      50 |
| 张秋丽       |          77 |      82 |
| 争青小子     |          56 |      48 |
| NULL         |          66 |      77 |
+--------------+-------------+---------+
6 rows in set (0.00 sec)

```

```
思考：
select * from 表1 left join 表2 on 表1.公共字段=表2.公共字段
和
select * from 表2 right join 表1 on 表1.公共字段=表2.公共字段  是否一样？

答：一样的
```

### 1.4 交叉连接 [cross join]

插入测试数据

```mysql
MySQL [test2]> create table t3( id int, name varchar(10) );
Query OK, 0 rows affected (0.44 sec)

MySQL [test2]> insert into t3 values (1,'tom'),(2,'berry');
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

MySQL [test2]> create table t4( id int,
    -> scre int);
Query OK, 0 rows affected (0.08 sec)

MySQL [test2]> insert into t4 values (1,88),(2,99);
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0
```


语法
```mysql
select 列表 from 表1 cross join 表2; # 返回笛卡尔积
```

例题

1. 如果没有表达式返回的是笛卡尔积

```mysql
MySQL [test2]> select * from t3 cross join t4;
+------+-------+------+------+
| id   | name  | id   | scre |
+------+-------+------+------+
|    1 | tom   |    1 |   88 |
|    2 | berry |    1 |   88 |
|    1 | tom   |    2 |   99 |
|    2 | berry |    2 |   99 |
+------+-------+------+------+
4 rows in set (0.00 sec)

```

2. 如果有表达式等价于内连接

```mysql
MySQL [test2]> select * from t3 cross join t4 on t3.id=t4.id;
+------+-------+------+------+
| id   | name  | id   | scre |
+------+-------+------+------+
|    1 | tom   |    1 |   88 |
|    2 | berry |    2 |   99 |
+------+-------+------+------+
2 rows in set (0.00 sec)

```

### 1.5 自然连接 [natural]

```mysql
自动的判断连接条件，它是过同名字段来判断的
```

自然连接又分为:

1. 自然内连接   natural join
2. 自然左外连接 natural left join
3. 自然右外连接 natural right join

例题

#### 1.5.1 自然内连接

```mysql
MySQL [test2]> select * from stuinfo natural join stuMarks;
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress | examNo  | writtenExam | labExam |
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       | s271811 |          80 |      58 |
| s25302 | 李文才       | 男     |     31 |       3 | 上海       | s271813 |          50 |      90 |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       | s271815 |          65 |      50 |
| s25301 | 张秋丽       | 男     |     18 |       1 | 北京       | s271816 |          77 |      82 |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       | s271819 |          56 |      48 |
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
5 rows in set (0.00 sec)

```

#### 1.5.2 自然左外连接

```mysql
MySQL [test2]> select * from stuinfo natural left join stuMarks;
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress | examNo  | writtenExam | labExam |
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       | s271811 |          80 |      58 |
| s25302 | 李文才       | 男     |     31 |       3 | 上海       | s271813 |          50 |      90 |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       | s271815 |          65 |      50 |
| s25301 | 张秋丽       | 男     |     18 |       1 | 北京       | s271816 |          77 |      82 |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       | s271819 |          56 |      48 |
| s25305 | 诸葛丽丽     | 女     |     23 |       7 | 河南       | NULL    |        NULL |    NULL |
| s25319 | 梅超风       | 女     |     23 |       5 | 河北       | NULL    |        NULL |    NULL |
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
```

#### 1.5.3 自然右外连接

```mysql
MySQL [test2]> select * from stuinfo natural right join stuMarks;
+--------+---------+-------------+---------+--------------+--------+--------+---------+------------+
| stuNo  | examNo  | writtenExam | labExam | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+---------+-------------+---------+--------------+--------+--------+---------+------------+
| s25303 | s271811 |          80 |      58 | 李斯文       | 女     |     22 |       2 | 北京       |
| s25302 | s271813 |          50 |      90 | 李文才       | 男     |     31 |       3 | 上海       |
| s25304 | s271815 |          65 |      50 | 欧阳俊雄     | 男     |     28 |       4 | 天津       |
| s25301 | s271816 |          77 |      82 | 张秋丽       | 男     |     18 |       1 | 北京       |
| s25318 | s271819 |          56 |      48 | 争青小子     | 男     |     26 |       6 | 天津       |
| s25320 | s271820 |          66 |      77 | NULL         | NULL   |   NULL |    NULL | NULL       |
+--------+---------+-------------+---------+--------------+--------+--------+---------+------------+
6 rows in set (0.00 sec)

```

自然连接结论：
1. 表连接通过同名字段来连接的
2. 如果没有同名字段返回笛卡尔积
3. 会对结果进行整理，整理的规则如下

	- 连接字段保留一个
	- 连接字段放在最前面
	- 左外连接左表在前，右外连接有表在前  


### 1.6 using()

1. 用来指定连接字段
2. using()也会对连接字段进行整理，整理方式和自然连接是一样的。

```mysql
MySQL [test2]> select * from stuinfo inner join stuMarks using(stuno) ;
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress | examNo  | writtenExam | labExam |
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       | s271811 |          80 |      58 |
| s25302 | 李文才       | 男     |     31 |       3 | 上海       | s271813 |          50 |      90 |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       | s271815 |          65 |      50 |
| s25301 | 张秋丽       | 男     |     18 |       1 | 北京       | s271816 |          77 |      82 |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       | s271819 |          56 |      48 |
+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+
5 rows in set (0.00 sec)
```

## 二、子查询

语法
```mysql
select 语句 where 条件 (select ... from 表)
```

1. 外面的查询成为父查询，括号内的查询称为子查询
2. 子查询为父查询提供查询条件

### 2.1 例题

1. 查找笔试80分的学生

```mysql
#方法一
MySQL [test2]> select * from stuinfo where stuno=(select stuno from stuMarks where writtenexam=80);
+--------+-----------+--------+--------+---------+------------+
| stuNo  | stuName   | stuSex | stuAge | stuSeat | stuAddress |
+--------+-----------+--------+--------+---------+------------+
| s25303 | 李斯文    | 女     |     22 |       2 | 北京       |
+--------+-----------+--------+--------+---------+------------+
1 row in set (0.00 sec)

#方法二
MySQL [test2]> select * from stuinfo where stuno=(select stuno from stuMarks where writtenexam=(select max(writtenexam) from stuMarks));
+--------+-----------+--------+--------+---------+------------+
| stuNo  | stuName   | stuSex | stuAge | stuSeat | stuAddress |
+--------+-----------+--------+--------+---------+------------+
| s25303 | 李斯文    | 女     |     22 |       2 | 北京       |
+--------+-----------+--------+--------+---------+------------+
1 row in set (0.00 sec)

```

2. 查找笔试最高分的学生

```mysql
MySQL [test2]> select * from stuinfo where stuno=(select stuno from stuMarks order by writtenexam desc limit 1);
+--------+-----------+--------+--------+---------+------------+
| stuNo  | stuName   | stuSex | stuAge | stuSeat | stuAddress |
+--------+-----------+--------+--------+---------+------------+
| s25303 | 李斯文    | 女     |     22 |       2 | 北京       |
+--------+-----------+--------+--------+---------+------------+
1 row in set (0.00 sec)
```
>脚下留心：上面的例题，子查询只能返回一个值。如果子查询返回多个值就不能用“=”了,需要用 in
### 2.2 in|not in 子查询

用于子查询的返回结果为多个值

1. 查找笔试成绩及格的同学
```mysql
MySQL [test2]> select * from stuinfo where stuno in (select stuno from stuMarks where writtenexam>=60);
+--------+--------------+--------+--------+---------+------------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+--------------+--------+--------+---------+------------+
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       |
| s25301 | 张秋丽       | 男     |     18 |       1 | 北京       |
+--------+--------------+--------+--------+---------+------------+
3 rows in set (0.00 sec)
```

2. 查询不及格的同学

```msyql
MySQL [test2]> select * from stuinfo where stuno in (select stuno from stuMarks where writtenexam<60);
+--------+--------------+--------+--------+---------+------------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+--------------+--------+--------+---------+------------+
| s25302 | 李文才       | 男     |     31 |       3 | 上海       |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       |
+--------+--------------+--------+--------+---------+------------+
2 rows in set (0.00 sec)
```

3、查询没有通过的同学（不及格，缺考）

```mysql
MySQL [test2]> select * from stuinfo where stuno not in (select stuno from stuMarks where writtenexam>=60);
+--------+--------------+--------+--------+---------+------------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+--------------+--------+--------+---------+------------+
| s25302 | 李文才       | 男     |     31 |       3 | 上海       |
| s25305 | 诸葛丽丽     | 女     |     23 |       7 | 河南       |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       |
| s25319 | 梅超风       | 女     |     23 |       5 | 河北       |
+--------+--------------+--------+--------+---------+------------+
4 rows in set (0.00 sec)

```

### 2.3 exists 和 not exists

1.	如果有人笔试超过80分就显示所有的学生

```mysql
MySQL [test2]> select * from stuinfo where exists (select * from stuMarks where writtenexam>=80);
+--------+--------------+--------+--------+---------+------------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+--------------+--------+--------+---------+------------+
| s25301 | 张秋丽       | 男     |     18 |       1 | 北京       |
| s25302 | 李文才       | 男     |     31 |       3 | 上海       |
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       |
| s25305 | 诸葛丽丽     | 女     |     23 |       7 | 河南       |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       |
| s25319 | 梅超风       | 女     |     23 |       5 | 河北       |
+--------+--------------+--------+--------+---------+------------+
7 rows in set (0.00 sec)

```

2.	如果没有人超过80分就显示所有的学生

```mysql
MySQL [test2]> select * from stuinfo where not exists (select * from stuMarks where writtenexam>=80);
Empty set (0.00 sec)
```


### 2.4 子查询分类

1. 标量子查询：子查询返回的结果就一个

2. 列子查询：子查询返回的结果是一个列表

3. 行子查询：子查询返回的结果是一行

例题：查询成绩最高的男生和女生

```mysql
MySQL [test2]> select stuname,stusex,ch from stu where (stusex,ch) in (select stusex,max(ch) from stu group by stusex);
+--------------+--------+------+
| stuname      | stusex | ch   |
+--------------+--------+------+
| 争青小子     | 男     |   86 |
| Tabm         | 女     |   88 |
+--------------+--------+------+
2 rows in set (0.01 sec)

```

4. 表子查询：子查询返回的结果当成一个表

例题：查询成绩最高的男生和女生

```mysql
mysql> select stuname,stusex,ch from (select * from stu order by ch desc) as t group by stusex;
+----------+--------+------+
| stuname  | stusex | ch   |
+----------+--------+------+
| Tabm     | 女      |   88 |
| 争青小子        | 男       |   86 |
+----------+--------+------+
```

```
脚下留心：from后面是一个表，如果子查询的结果当成表来看，必须将子查询的结果取别名。
```

## 3 视图 view

1. 视图是一张虚拟表，他表示的一部分或者多张表的综合机构
2. 视图仅仅是表结构，没有表数据，视图的几条狗和表数据建立在表的基础上

### 3.1 创建视图

语法：

```mysql
create [or replace] view 视图的名称
as
	select 语句
```

例题

```mysql
MySQL [test2]> create view vw_stu 
    -> as 
    -> select stuname,stusex,writtenexam,labexam from stuinfo inner join stumarks using(stuno);
Query OK, 0 rows affected (0.02 sec)
```

```mysql
多学一招：因为视图是一个表结构，所以创建视图后，会在数据库文件夹中多一个与视图名同名的.frm文件
```

### 3.2 使用视图

视图是一张虚拟表，视图的用法和表的用法一箱

```mysql
MySQL [test2]> select * from vw_stu;
+--------------+--------+-------------+---------+
| stuname      | stusex | writtenexam | labexam |
+--------------+--------+-------------+---------+
| 李斯文       | 女     |          80 |      58 |
| 李文才       | 男     |          50 |      90 |
| 欧阳俊雄     | 男     |          65 |      50 |
| 张秋丽       | 男     |          77 |      82 |
| 争青小子     | 男     |          56 |      48 |
+--------------+--------+-------------+---------+
5 rows in set (0.00 sec)
```

### 3.3 查看视图的结构

语法

```
desc 视图名
```

例题

```mysql
MySQL [test2]> desc vw_stu;
+-------------+-------------+------+-----+---------+-------+
| Field       | Type        | Null | Key | Default | Extra |
+-------------+-------------+------+-----+---------+-------+
| stuname     | varchar(10) | NO   |     | NULL    |       |
| stusex      | char(2)     | NO   |     | NULL    |       |
| writtenexam | int(11)     | YES  |     | NULL    |       |
| labexam     | int(11)     | YES  |     | NULL    |       |
+-------------+-------------+------+-----+---------+-------+
4 rows in set (0.01 sec)
```

### 3.4 查看创建视图的语法

```mysql
MySQL [test2]> show create view vw_stu\G
*************************** 1. row ***************************
                View: vw_stu
         Create View: CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`%` SQL SECURITY DEFINER VIEW `vw_stu` AS select `stuinfo`.`stuName` AS `stuname`,`stuinfo`.`stuSex` AS `stusex`,`stumarks`.`writtenExam` AS `writtenexam`,`stumarks`.`labExam` AS `labexam` from (`stuinfo` join `stumarks` on((`stuinfo`.`stuNo` = `stumarks`.`stuNo`)))
character_set_client: utf8
collation_connection: utf8_general_ci
1 row in set (0.00 sec)
```

### 3.5 显示所有视图

```mysql
#方法一
MySQL [test2]> show tables;
+-----------------+
| Tables_in_test2 |
+-----------------+
| stu             |
| stuinfo         |
| stumarks        |
| test5           |
| vw_stu          |
+-----------------+
5 rows in set (0.00 sec


#方法二
MySQL [test2]> select table_name from information_schema.views;
+-----------------------------------------------+
| table_name                                    |
+-----------------------------------------------+
| vw_stu                                        |
+-----------------------------------------------+

#方法三
MySQL [test2]> show table status where comment= 'view'\G
*************************** 1. row ***************************
           Name: vw_stu
         Engine: NULL
        Version: NULL
     Row_format: NULL
           Rows: NULL
 Avg_row_length: NULL
    Data_length: NULL
Max_data_length: NULL
   Index_length: NULL
      Data_free: NULL
 Auto_increment: NULL
    Create_time: NULL
    Update_time: NULL
     Check_time: NULL
      Collation: NULL
       Checksum: NULL
 Create_options: NULL
        Comment: VIEW
1 row in set (0.00 sec)

```

### 3.6 更改地图

语法:
```mysql
slter view 视图名
as
	select 语句
```

例题

```mysql
MySQL [test2]> alter view vw_stu
    -> as
    -> select * from stuinfo;
Query OK, 0 rows affected (0.02 sec)
```

### 3.7 删除视图

语法：

```mysql
drop view [if exists] 视图1,视图2,...
```

例题

```mysql
MySQL [test2]> drop view vw_stu;
Query OK, 0 rows affected (0.00 sec)

```

### 3.8 视图的作用

1. 筛选数据，防止未经许可的敏感数据
2. 隐藏表结构
3. 降低SQL语句的复杂度

### 3.9 视图算法
普通不指定算法
```
MySQL [test2]>  select * from vw_stu group by stusex;
+--------+-----------+--------+--------+---------+------------+------+------+
| stuNo  | stuName   | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+-----------+--------+--------+---------+------------+------+------+
| s25301 | 张秋丽    | 男     |     18 |       1 | 北京       |   80 | NULL |
| s25303 | 李斯文    | 女     |     22 |       2 | 北京       |   55 |   82 |
+--------+-----------+--------+--------+---------+------------+------+------+
2 rows in set (0.00 sec)
```

```
1. merge：合并算法，将视图的语句和外层的语句合并后在执行。
2. temptable：临时表算法，将视图生成一个临时表，再执行外层语句
3. undefined：未定义，MySQL到底用merge还是用temptable由MySQL决定，这是一个默认的算法，一般视图都会选择merge算法，因为merge效率高。
```

解决：在创建视图的时候指定视图的算法

```mysql
create algorithm=temptable view 视图名
as
	select 语句
```

指定算法创建视图   

```mysql
mysql> create algorithm=temptable view vw_stu
    -> as
    ->  select * from stu order by ch desc;
Query OK, 0 rows affected (0.00 sec)


MySQL [test2]>  select * from vw_stu1 group by stusex;
+--------+--------------+--------+--------+---------+------------+------+------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress | ch   | math |
+--------+--------------+--------+--------+---------+------------+------+------+
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       |   86 |   92 |
| s25321 | Tabm         | 女     |     23 |       9 | 河北       |   88 |   77 |
+--------+--------------+--------+--------+---------+------------+------+------+
2 rows in set (0.00 sec)

```

## 4. 事物[transaction]

1. 事物是一个不可分割的执行单元
2. 事物作为一个整体要么一起执行，要么一起回滚

### 4.1 事物操作

```mysql
开始事物：start transaction 或者 begin [work]
提交事物：commit
回滚事物：rollback
```

插入测试数据

```mysql
MySQL [test2]> 
MySQL [test2]> create table bank(
    -> cardid char(4) primary key,
    -> money int
    -> );
Query OK, 0 rows affected (0.05 sec)

MySQL [test2]> insert into bank values ('1001',1000),('1002',100);
Query OK, 2 rows affected (0.04 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

例题

提交事务commit
```mysql
MySQL [test2]> start transaction;
    -> update bank set money=money-100 where cardid='1001';
    -> update bank set money=money+100 where cardid='1002';
    -> //
Query OK, 0 rows affected (0.00 sec)

Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

MySQL [test2]> commit//
Query OK, 0 rows affected (0.03 sec)

MySQL [test2]> select * from bank;//
+--------+-------+
| cardid | money |
+--------+-------+
| 1001   |   900 |
| 1002   |   200 |
+--------+-------+
2 rows in set (0.00 sec)

```

回滚事物rollback
```mysql
MySQL [test2]> start transaction; update bank set money=money-100 where cardid='1001'; update bank set money=money+100 where cardid='1002';//
Query OK, 0 rows affected (0.00 sec)

Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

MySQL [test2]> select * from bank;//
+--------+-------+
| cardid | money |
+--------+-------+
| 1001   |   800 |
| 1002   |   300 |
+--------+-------+
2 rows in set (0.00 sec)

MySQL [test2]> rollback//
Query OK, 0 rows affected (0.16 sec)

MySQL [test2]> select * from bank;//
+--------+-------+
| cardid | money |
+--------+-------+
| 1001   |   900 |
| 1002   |   200 |
+--------+-------+
2 rows in set (0.00 sec)

```

```
思考：事务什么时候产生？什么时候结束？
答：开启的时候产生，提交事务或回滚事务都结束

脚下留心：只有innodb和BDB才支持事务，myisam不支持事务。
```

### 4.2 设置事物回滚点

语法

```
设置回滚点：savepoint 回滚点名
回滚回滚点：rollback to 回滚点
```

例题

```mysql
MySQL [test2]> delimiter ;
MySQL [test2]> start transaction;
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> insert into bank value ('1001',1000);
ERROR 1062 (23000): Duplicate entry '1001' for key 'PRIMARY'
MySQL [test2]> insert into bank value ('1003',1000);
Query OK, 1 row affected (0.00 sec)

MySQL [test2]> savepoint aa; #设置回滚点aa
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> insert into bank value ('1004',500);
Query OK, 1 row affected (0.00 sec)

MySQL [test2]> savepoint bb; #设置回滚点bb 
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> rollback to aa; #回滚到aa
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> commit; #提交事务
Query OK, 0 rows affected (0.13 sec)

MySQL [test2]> select * from bank;
+--------+-------+
| cardid | money |
+--------+-------+
| 1001   |   900 |
| 1002   |   200 |
| 1003   |  1000 |
+--------+-------+
3 rows in set (0.00 sec)

```

#### 4.3	事务的特性（ACID）

1. 原子性（Atomicity）：事务是一个整体，不可以再分，要么一起执行，要么一起不执行。
2. 一致性（Consistency）：事务完成时，数据必须处于一致的状态。
3. 隔离性（Isolation）：每个事务都是相互隔离的
4. 永久性（Durability）：事务完成后，对数据的修改是永久性的。

## 5. 索引 [index]

- 索引的有点：查询速度快
- 索引的缺点：
	1. 增、删、改(数据操作语句)效率降低了
	2. 索引占用空间

### 5.1 索引类型

1. 普通索引
2. 唯一索引(唯一键)
3. 主键索引: 只要主键就自动创建主键索引，不需要手动创建。
4. 全文索引：索引引擎使用，MySQL 不支持中文的全文索引，需要我们通过sphinx去解决中文的全文索引。

### 5.2 创建普通索引[create index]

语法：
```mysql
create index [索引名] on 表名 (字段名)
alter table 表名 add index [索引名] (列名)
```

例题

```mysql
MySQL [test2]> #创建索引方法一
MySQL [test2]> create index ix_stuname on stuinfo(stuname);
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

MySQL [test2]> #创建索引方法二
MySQL [test2]> alter table stuinfo add index ix_address (stuaddress);
Query OK, 0 rows affected (0.26 sec)
Records: 0  Duplicates: 0  Warnings: 0

MySQL [test2]> #创建表的时候就添加索引
MySQL [test2]> create table tmp(
    -> id int,
    -> name varchar(10),
    -> index ix_name(name) #创建索引
    -> );
Query OK, 0 rows affected (0.43 sec)
```

### 5.3 创建唯一索引

```mysql
语法一：create unique index 索引名 on 表名 (字段名)
语法二：alter table 表名 add unique [index] [索引名] (列名)
语法三：创建表的时候添加唯一索引，和创建唯一键是一样的。
```

例题

```mysql
#方法一
MySQL [test2]> create unique index UQ_stuname on stu(stuname);
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0

#方法二
MySQL [test2]> alter table stu add unique UQ_address(stuaddress);
Query OK, 0 rows affected (0.07 sec)
Records: 0  Duplicates: 0  Warnings: 0

#方法三
MySQL [test2]> create table tmp2(
    -> id int,
    -> name varchar(20),
    -> unique UQ_name(name)
    -> );
Query OK, 0 rows affected (0.08 sec)

```

### 5.4 删除索引

语法

```mysql
drop index 索引 on 表名
```

```mysql
MySQL [test2]> drop index ix_stuname on stuinfo;
Query OK, 0 rows affected (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

### 5.5 创建索引的知道原则

1. 该列用于频繁搜索
2. 该列用于排序
3. 公共字段要创建索引
4. 如果表中的数据很少，不需要创建索引。Mysql搜索索引的时间比逐条搜索数据的时间要长
5. 如果一个字段上的数据只有几个不同的值，该字段不适合做索引，比如性别。

## 6. 函数

### 6.1 数字类

#### 6.1.1 生成随机数

```mysql
MySQL [test2]> select rand();
+---------------------+
| rand()              |
+---------------------+
| 0.48848650743112576 |
+---------------------+
1 row in set (0.00 sec)

MySQL [test2]> select * from stuinfo order by rand();
+--------+--------------+--------+--------+---------+------------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+--------------+--------+--------+---------+------------+
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       |
| s25301 | 张秋丽       | 男     |     18 |       1 | 北京       |
| s25305 | 诸葛丽丽     | 女     |     23 |       7 | 河南       |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       |
| s25319 | 梅超风       | 女     |     23 |       5 | 河北       |
| s25302 | 李文才       | 男     |     31 |       3 | 上海       |
+--------+--------------+--------+--------+---------+------------+
7 rows in set (0.00 sec)
```

#### 6.1.2 四舍五入

```mysql
MySQL [test2]> select round(3.5);
+------------+
| round(3.5) |
+------------+
|          4 |
+------------+
1 row in set (0.00 sec)
```

#### 6.1.3 向上取整

```mysql
MySQL [test2]> select ceil(3.1);
+-----------+
| ceil(3.1) |
+-----------+
|         4 |
+-----------+
1 row in set (0.00 sec)
```

#### 6.1.4 向下取整

```mysql
MySQL [test2]> select floor(3.9);
+------------+
| floor(3.9) |
+------------+
|          3 |
+------------+
1 row in set (0.00 sec)
```

#### 6.1.5 截取数字

```mysql
MySQL [test2]> select truncate(3.1415926,3);
+-----------------------+
| truncate(3.1415926,3) |
+-----------------------+
|                 3.141 |
+-----------------------+
1 row in set (0.00 sec)
```

### 6.2 字符串类

#### 6.2.1 转大写

```mysql
MySQL [test2]> select ucase('i am a boy!');
+----------------------+
| ucase('i am a boy!') |
+----------------------+
| I AM A BOY!          |
+----------------------+
1 row in set (0.00 sec)
```

#### 6.2.2 转小写

```mysql
MySQL [test2]> select lcase('I AM A BOY!');
+----------------------+
| lcase('I AM A BOY!') |
+----------------------+
| i am a boy!          |
+----------------------+
1 row in set (0.00 sec)
```

#### 6.2.3 从左截取

```mysql
#从左截取3个字符
MySQL [test2]> select left('abcde',3);
+-----------------+
| left('abcde',3) |
+-----------------+
| abc             |
+-----------------+
1 row in set (0.00 sec)
```

#### 6.2.4 从右截取

```mysql
#从右截取三个字符
MySQL [test2]> select right('abcde',3);
+------------------+
| right('abcde',3) |
+------------------+
| cde              |
+------------------+
1 row in set (0.00 sec)
```

#### 6.2.5 从指定位置截取

```mysql
# 从第2个位置截取3个字符，位置从1开始
MySQL [test2]> select substring('abcde',2,3); 
+------------------------+
| substring('abcde',2,3) |
+------------------------+
| bcd                    |
+------------------------+
1 row in set (0.00 sec)
```

#### 6.2.6 字符串连接

```mysql
MySQL [test2]> select concat('中国','上海');
+---------------------------+
| concat('中国','上海')     |
+---------------------------+
| 中国上海                  |
+---------------------------+
1 row in set (0.00 sec)

#将表里的姓名和性别连接起来
MySQL [test2]> select concat(stuname,'-',stusex) from stuinfo;
+----------------------------+
| concat(stuname,'-',stusex) |
+----------------------------+
| 张秋丽-男                  |
| 李文才-男                  |
| 李斯文-女                  |
| 欧阳俊雄-男                |
| 诸葛丽丽-女                |
| 争青小子-男                |
| 梅超风-女                  |
+----------------------------+
7 rows in set (0.00 sec)

```

#### 6.2.7 空字段值替换

```mysql
#将成绩为空的人显示为缺考
MySQL [test2]> select stuname,coalesce(writtenexam,'缺考'),coalesce(labexam,'缺考') from stuinfo natural left join stumarks;
+--------------+--------------------------------+----------------------------+
| stuname      | coalesce(writtenexam,'缺考')   | coalesce(labexam,'缺考')   |
+--------------+--------------------------------+----------------------------+
| 李斯文       | 80                             | 58                         |
| 李文才       | 50                             | 90                         |
| 欧阳俊雄     | 65                             | 50                         |
| 张秋丽       | 77                             | 82                         |
| 争青小子     | 56                             | 48                         |
| 诸葛丽丽     | 缺考                           | 缺考                       |
| 梅超风       | 缺考                           | 缺考                       |
+--------------+--------------------------------+----------------------------+
7 rows in set (0.00 sec)
```

#### 6.2.8 统计字节长度

```mysql
# utf-8 汉子占用3个字节
MySQL [test2]> select length('锄禾日当午');
+---------------------------+
| length('锄禾日当午')      |
+---------------------------+
|                        15 |
+---------------------------+
1 row in set (0.00 sec)
```

### 6.3 时间类

#### 6.3.1 获取时间戳

```mysql
MySQL [test2]> select unix_timestamp();
+------------------+
| unix_timestamp() |
+------------------+
|       1563332659 |
+------------------+
1 row in set (0.00 sec)
```
#### 6.3.2 时间戳格式转换

```mysql
# 将时间戳转成年-月-日 时:分:秒的格式

MySQL [test2]> select from_unixtime(unix_timestamp());
+---------------------------------+
| from_unixtime(unix_timestamp()) |
+---------------------------------+
| 2019-07-17 03:04:44             |
+---------------------------------+
1 row in set (0.00 sec)
```


#### 6.3.3 获取当前日期时间

```mysql
MySQL [test2]> select now();
+---------------------+
| now()               |
+---------------------+
| 2019-07-17 03:07:59 |
+---------------------+
1 row in set (0.00 sec)


# 当前年、月、日、时、分、秒但如显示
MySQL [test2]> select year(now()) 年,month(now()) 月, day(now()) 日, hour(now()) 时, minute(now()) 分,second(now()) 秒;
+------+------+------+------+------+------+
| 年   | 月   | 日   | 时   | 分   | 秒   |
+------+------+------+------+------+------+
| 2019 |    7 |   17 |    3 |   10 |   12 |
+------+------+------+------+------+------+
1 row in set (0.00 sec)

# 当年的第几天
MySQL [test2]> select dayname(now()) 星期,monthname(now()),dayofyear(now()) 本年的第几天;
+-----------+------------------+--------------------+
| 星期      | monthname(now()) | 本年的第几天       |
+-----------+------------------+--------------------+
| Wednesday | July             |                198 |
+-----------+------------------+--------------------+
1 row in set (0.00 sec)


# 将now转换为日期和时间的两种方式
# 方式一
MySQL [test2]> select convert(now(),date),convert(now(),time);
+---------------------+---------------------+
| convert(now(),date) | convert(now(),time) |
+---------------------+---------------------+
| 2019-07-17          | 03:19:14            |
+---------------------+---------------------+
1 row in set (0.00 sec)

# 方式二
MySQL [test2]> select cast(now() as date),cast(now() as time);
+---------------------+---------------------+
| cast(now() as date) | cast(now() as time) |
+---------------------+---------------------+
| 2019-07-17          | 03:20:26            |
+---------------------+---------------------+
1 row in set (0.00 sec)


```

### 6.4 加密函数

语法

```mysql
if(表达式,值1,值2)
```

例题

```mysql
MySQL [test2]> select stuname,ch,math,if(ch>=60 && math <=60 ,'通过','不通过') '是否通过' from stu;
+--------------+------+------+--------------+
| stuname      | ch   | math | 是否通过     |
+--------------+------+------+--------------+
| 张秋丽       |   80 | NULL | 不通过       |
| 李文才       |   77 |   76 | 不通过       |
| 李斯文       |   55 |   82 | 不通过       |
| 欧阳俊雄     | NULL |   74 | 不通过       |
| 诸葛丽丽     |   72 |   56 | 通过         |
| 争青小子     |   86 |   92 | 不通过       |
| 梅超风       |   74 |   67 | 不通过       |
| Tom          |   65 |   67 | 不通过       |
| Tabm         |   88 |   77 | 不通过       |
+--------------+------+------+--------------+
9 rows in set (0.00 sec)
```

## 7 预处理

预编译一次，可以多次执行。用来解决一套sql语句频繁执行的问题
```
预处理语句 prepare 预处理名字 from 'sql语句'
执行预处理 execute 预处理名字 [using 变量]
```

例题一:

```mysql
MySQL [test2]> prepare stmt from 'select * from stuinfo'; # 创建预处理
Query OK, 0 rows affected (0.00 sec)
Statement prepared

MySQL [test2]> execute stmt;
+--------+--------------+--------+--------+---------+------------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+--------------+--------+--------+---------+------------+
| s25301 | 张秋丽       | 男     |     18 |       1 | 北京       |
| s25302 | 李文才       | 男     |     31 |       3 | 上海       |
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       |
| s25305 | 诸葛丽丽     | 女     |     23 |       7 | 河南       |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       |
| s25319 | 梅超风       | 女     |     23 |       5 | 河北       |
+--------+--------------+--------+--------+---------+------------+
7 rows in set (0.00 sec)

```

例题二:

```mysql
Database changed
MySQL [test2]> delimiter //
MySQL [test2]> prepare stmt from 'select * from stuinfo where stuno=?' //
Query OK, 0 rows affected (0.00 sec)
Statement prepared

MySQL [test2]> set @id='s25301';
    -> execute stmt using @id;
    -> //
Query OK, 0 rows affected (0.00 sec)
+--------+-----------+--------+--------+---------+------------+
| stuNo  | stuName   | stuSex | stuAge | stuSeat | stuAddress |
+--------+-----------+--------+--------+---------+------------+
| s25301 | 张秋丽    | 男     |     18 |       1 | 北京       |
+--------+-----------+--------+--------+---------+------------+
1 row in set (0.00 sec)

```

```
脚下留心：
1、?是位置占位符
2、变量以@开头
3、通过set给变量赋值
```

例题三:

```mysql
MySQL [test2]> prepare stmt from 'select * from stuinfo where stusex=? or stuaddress=?'//
Query OK, 0 rows affected (0.00 sec)
Statement prepared

MySQL [test2]> set @sex='男'; set @addr='北京'; execute stmt using @sex,@addr//
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

+--------+-----------+--------+--------+---------+------------+
| stuNo  | stuName   | stuSex | stuAge | stuSeat | stuAddress |
+--------+-----------+--------+--------+---------+------------+
| s25301 | 张秋丽    | 男     |     18 |       1 | 北京       |
+--------+-----------+--------+--------+---------+------------+
1 row in set (0.00 sec)

```

## 8 存储过程

### 8.1 存储过程的优先

1. 存储过程可以减少网络流量
2. 允许模块化设计
3. 支持事务

### 8.2 创建存储过程

语法：

```mysql
create procedure 存储过程(参数)
begin 
    //sql语句
end;
脚下留心：由于过程中有很多SQL语句，每个语句的结束都要用（；）结束。默认情况下，分号既表示语句结束，又表示向服务器发送SQL语句。我们希望分号仅表示语句的结束，不要将SQL语句发送到服务器执行，通过delimiter来更改结束符。
```

例题

```mysql
MySQL [test2]> create procedure proc()
    -> begin
    -> select * from stuinfo;
    -> end //
Query OK, 0 rows affected (0.00 sec)
```

### 8.3 调用存储过程

语法：
```mysql
call 存储过程名()
```

例题
```mysql
MySQL [test2]> call proc()//
+--------+--------------+--------+--------+---------+------------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+--------------+--------+--------+---------+------------+
| s25301 | 张秋丽       | 男     |     18 |       1 | 北京       |
| s25302 | 李文才       | 男     |     31 |       3 | 上海       |
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       |
| s25305 | 诸葛丽丽     | 女     |     23 |       7 | 河南       |
| s25318 | 争青小子     | 男     |     26 |       6 | 天津       |
| s25319 | 梅超风       | 女     |     23 |       5 | 河北       |
+--------+--------------+--------+--------+---------+------------+
7 rows in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)
```

### 8.4 查看存储过程的信息
```mysql
show create procedure 存储过程名
```

例题

```mysql
MySQL [test2]> show create procedure proc\G
*************************** 1. row ***************************
           Procedure: proc
            sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
    Create Procedure: CREATE DEFINER=`root`@`%` PROCEDURE `proc`()
begin
select * from stuinfo;
end
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: gbk_chinese_ci
1 row in set (0.00 sec)
```

### 8.5 删除存储过程
语法
```
drop procedure 存储过程名
```

例题

```mysql
MySQL [test2]> drop procedure proc//
Query OK, 0 rows affected (0.01 sec)

```

### 8.6 显示所有的存储过程

```mysql
MySQL [test2]> show procedure status \G
```

### 8.7 存储过程的参数

存储过程的参数分为：输入参数(in) [默认], 输出参数(out) ,输入输出参数(inout)

存储过程不能使用return返回值，返回值只能通过"输出参数"来向外传递值

例题一：传递学号，获取对应信息
```mysql
MySQL [test2]> create procedure pro (in param varchar(10))
    -> select * from stuinfo where stuno=param//
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> call pro('s25301')//
+--------+-----------+--------+--------+---------+------------+
| stuNo  | stuName   | stuSex | stuAge | stuSeat | stuAddress |
+--------+-----------+--------+--------+---------+------------+
| s25301 | 张秋丽    | 男     |     18 |       1 | 北京       |
+--------+-----------+--------+--------+---------+------------+
1 row in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)
```

例题二：查找同桌
```mysql
MySQL [test2]> create procedure pro1(name varchar(10)) 
    -> begin 
    -> declare seat tinyint;  
    -> select stuseat into seat from stuinfo where stuname=name; # 将座位号保存到变量中
    -> select * from stuinfo where stuseat=seat+1 or stuseat=seat-1;   # 找同桌
    -> end//
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> call pro1('李文才')//
+--------+--------------+--------+--------+---------+------------+
| stuNo  | stuName      | stuSex | stuAge | stuSeat | stuAddress |
+--------+--------------+--------+--------+---------+------------+
| s25303 | 李斯文       | 女     |     22 |       2 | 北京       |
| s25304 | 欧阳俊雄     | 男     |     28 |       4 | 天津       |
+--------+--------------+--------+--------+---------+------------+
2 rows in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

```

强调

```mysql
1、通过declare关键字声明局部变量；全局变量@开头就可以了
2、给变量赋值有两种方法
	方法一：set 变量名=值
	方法二：select 字段 into 变量 from 表 where 条件
3、声明的变量不能与列名同名
```

例题三：输出参数

```mysql
MySQL [test2]> create procedure proc(num int ,out result int)  begin set result=num*num; end//
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> call proc(10,@result)//
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> select @result//
+---------+
| @result |
+---------+
|     100 |
+---------+
1 row in set (0.00 sec)
```

例题四：输入输出参数

```mysql
MySQL [test2]> create procedure pro2(inout num int) #inout表示输入输出参数
    -> begin
    -> set num=num*num;
    -> end //
Query OK, 0 rows affected (0.00 sec)

MySQL [test2]> set @num=10;
    -> call pro2(@num);
    -> select @num//
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

+------+
| @num |
+------+
|  100 |
+------+
1 row in set (0.00 sec)
```
